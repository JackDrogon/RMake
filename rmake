#!/usr/bin/env ruby
# frozen_string_literal: true

RMAKEFILE = 'rmakefile'

module EnvHelper
  def verbose
    if @env['VERBOSE']
      yield if block_given?
    end
  end
end

class Env
  def initialize(child)
    @child = child
    @table = {}
  end

  def [](key)
    @table[key] || @child[key]
  end

  def []=(key, value)
    if @table[key]
      @table[key] = value
    else
      @child[key] = value
    end
  end
end

class Task
  def initialize(env, cmd)
    @env = env
    @cmd = cmd
    @verbose = nil
  end

  def build
    verbose {puts "  --> #{@cmd}"}
    output = `#{@cmd}`
    print output
  end

private
  def verbose
    if @verbose.nil?
      # nil run first
      @verbose = true
      if @cmd.start_with?("@")
        @verbose = false
        @cmd[0] = ''
      end
    end

    if @verbose
      yield if block_given?
    end
  end
end

class Target
  attr_reader :name, :deps

  def initialize(env, name, deps, cmds, target_map)
    @env = env
    @name = name
    @deps = deps
    @tasks = (cmds || []).map { |cmd| Task.new(env, cmd) }
    @target_map = target_map
    @need_rebuild = nil
  end

  def rebuild?
    @need_rebuild = _rebuild? if @need_rebuild.nil?
    @need_rebuild
  end

  def build
    return unless rebuild?

    @deps.each do |dep|
      target = @target_map[dep]
      target&.build
    end
    @tasks.each(&:build)
    @need_rebuild = false
  end

  private

  def _rebuild?
    return true unless File.exist?(@name)

    @deps.any? do |dep|
      # PHONY task
      return true unless File.exist?(dep)

      target = @target_map[dep]
      if target.nil?
        # File task
        File.mtime(@name) < File.mtime(dep)
      elsif target.rebuild?
        true
      else
        File.mtime(@name) < File.mtime(target.name)
      end
    end
  end
end

class Token < Struct.new(:type, :data)
end

class Lexer
  DEPENDENCY = 1
  TASK = 2
  EOF = 3

  def initialize(env, rmakefile)
    @env = env
    @rmakefile = rmakefile
    @data = nil # buffer with lines
  end

  # nil is empty
  def next
    @data = File.readlines(@rmakefile) if @data.nil?

    line = @data.shift&.rstrip!
    if line.nil?
      Token.new(EOF, nil)
    elsif line.empty?
      self.next
    elsif line.start_with?("\t")
      # TASK
      line.lstrip!
      Token.new(TASK, line)
    else
      # DEPENDENCY
      Token.new(DEPENDENCY, line)
    end
  end
end

class RMake
  include EnvHelper

  def initialize(env, rmakefile, target_name)
    @env = env
    @rmakefile = rmakefile

    @parser = Lexer.new(env, rmakefile)

    @target_name = target_name
    @target_map = {}
    @targets = []

    _parse
  end

  def build
    target = @target_map[@target_name]
    target.build
  end

  def list_targets
    @target_map.keys
  end

  def run
    # TODO: check target not found
    unless @target_name
      puts "target #{@target_name} not found"
      exit(1)
    end

    verbose { puts '-------------------------' }
    build
  end

  private

  def _get_target
    return @target if @target

    @first_target
  end

  def _parse
    current_target = nil
    first_target = nil
    all_deps = {}
    tasks = {}

    loop do
      token = @parser.next
      case token.type
      when Lexer::DEPENDENCY
        # "total: 1.o 2.c 2.h 1.h" => ["total", "1.o 2.c 2.h 1.h"]
        # TODO: check end_with? ':'
        rules = token.data.split(':').map(&:strip)
        target_name = rules[0]
        first_target ||= target_name
        current_target = target_name
        # clean: => ["clean"]
        target_deps = [] # default for clean: just no deps
        unless rules.length == 1
          target_deps = rules[1].split.map(&:strip)
        end

        (all_deps[current_target] ||= []).concat(target_deps)
      when Lexer::TASK
        # ["gcc 1.o 2.c -o total"]
        unless current_target
          puts 'found rule before target'
          exit(1)
        end
        (tasks[current_target] ||= []) << token.data
      when Lexer::EOF
        break
      end
    end

    @target_name ||= first_target
    @targets = all_deps.map { |name, deps| Target.new(@env, name, deps, tasks[name], @target_map) }
    @targets.each { |t| @target_map[t.name] = t }

    verbose { pp @target_name }
    verbose { pp all_deps }
    verbose { pp tasks }
    verbose { pp @targets }
  end
end

def main
  target_name = nil
  target_name = ARGV[0] unless ARGV.empty?

  rmake = RMake.new(Env.new(ENV.to_hash), RMAKEFILE, target_name)
  puts '================================='
  puts '----- list targets -----'
  puts rmake.list_targets
  puts '================================='
  rmake.run
end

main if $LAST_READ_LINE != __FILE__
